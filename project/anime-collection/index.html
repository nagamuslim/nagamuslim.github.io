<!DOCTYPE html>
<html lang="id">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Anime Collection</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            background: linear-gradient(135deg, #0f0c29 0%, #302b63 50%, #24243e 100%);
            color: #e0e0e0;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            min-height: 100vh;
        }
        .header {
            background: rgba(0,0,0,0.3); backdrop-filter: blur(10px);
            padding: 20px; box-shadow: 0 4px 20px rgba(0,0,0,0.3);
            position: sticky; top: 0; z-index: 100;
        }
        .header-content { max-width: 1400px; margin: 0 auto; position: relative; }
        h1 { color: #fff; font-size: 2.5em; text-shadow: 2px 2px 4px rgba(0,0,0,0.5); margin-bottom: 6px; }
        .stats { color: #b0b0b0; font-size: 0.95em; margin-bottom: 14px; }
        
        .controls-row { display: flex; gap: 12px; max-width: 600px; }
        .search-input {
            flex: 1; padding: 12px 20px;
            border: 2px solid rgba(255,255,255,0.1);
            background: rgba(255,255,255,0.05);
            border-radius: 25px; color: white; font-size: 1em;
            transition: all 0.3s ease;
        }
        .search-input:focus { outline: none; border-color: rgba(102,126,234,0.5); background: rgba(255,255,255,0.08); }
        .search-input::placeholder { color: #888; }
        
        .sort-select {
            padding: 12px 16px; border-radius: 25px;
            border: 2px solid rgba(255,255,255,0.1);
            background: rgba(255,255,255,0.05);
            color: white; font-size: 1em; cursor: pointer;
            outline: none; transition: all 0.3s ease;
        }
        .sort-select:focus { border-color: rgba(102,126,234,0.5); }
        .sort-select option { background: #24243e; color: white; }

        #updateRow {
            position: absolute; top: 0; right: 0;
            display: flex; align-items: center; gap: 12px;
        }
        .update-btn {
            background: rgba(255,255,255,0.1); border: 1px solid rgba(255,255,255,0.2);
            color: white; padding: 8px 16px; border-radius: 8px;
            font-size: 0.85em; font-weight: 600; cursor: pointer;
            transition: all 0.3s ease; user-select: none;
        }
        .update-btn:hover { background: rgba(255,255,255,0.2); }
        .update-status { font-size: 0.82em; color: #a0a0a0; }
        
        .container { max-width: 1400px; margin: 0 auto; padding: 30px 20px; }
        .grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(300px, 1fr)); gap: 25px; }
        .anime-card {
            background: rgba(255,255,255,0.05); border-radius: 12px; overflow: hidden;
            transition: transform 0.3s ease, box-shadow 0.3s ease;
            border: 1px solid rgba(255,255,255,0.1);
            display: block; text-decoration: none; color: inherit; position: relative;
        }
        .anime-card:hover {
            transform: translateY(-8px); box-shadow: 0 15px 40px rgba(0,0,0,0.6);
            border-color: rgba(102,126,234,0.5);
        }
        .thumbnail { position: relative; width: 100%; padding-top: 56.25%; overflow: hidden; }
        .thumb-img { position: absolute; top:0; left:0; width:100%; height:100%; object-fit:cover; display:block; }
        .thumb-fallback {
            position: absolute; top:0; left:0; width:100%; height:100%;
            display: none; flex-direction: column; align-items: center; justify-content: center;
        }
        .badge {
            position: absolute; top: 10px; right: 10px; padding: 4px 8px;
            border-radius: 6px; font-size: 0.75em; font-weight: bold; color: white;
            box-shadow: 0 2px 10px rgba(0,0,0,0.5); z-index: 10;
        }
        .badge.donghua { background: linear-gradient(135deg, #ff4b2b, #ff416c); }
        .badge.dub { background: linear-gradient(135deg, #11998e, #38ef7d); }

        .anime-icon { font-size: 4em; opacity: 0.9; }
        .info { padding: 16px 18px 18px; }
        .title {
            color: #fff; font-size: 1.1em; font-weight: 600; margin-bottom: 6px; line-height: 1.4;
            display: -webkit-box; -webkit-line-clamp: 2; -webkit-box-orient: vertical;
            overflow: hidden; min-height: 3.1em;
        }
        .meta { color: #a0a0a0; font-size: 0.85em; }
        .loading { text-align: center; padding: 60px; color: #b0b0b0; font-size: 1.2em; }
        .no-results { text-align: center; padding: 60px; color: #888; grid-column: 1 / -1; }
        .no-results-icon { font-size: 4em; margin-bottom: 16px; opacity: 0.5; }
        @media (max-width: 768px) {
            h1 { font-size: 2em; }
            .grid { grid-template-columns: repeat(auto-fill, minmax(250px, 1fr)); gap: 16px; }
            .controls-row { flex-direction: column; }
            #updateRow { position: static; margin-bottom: 15px; }
        }
    </style>
</head>
<body>
    <div class="header">
        <div class="header-content">
            <h1>&#127916; Anime Collection</h1>
            <div class="stats" id="stats">Loading...</div>

            <div id="updateRow" style="display:none;">
                <label style="cursor:pointer;">
                    <input type="file" id="txtFileInput" accept=".txt,.zip" multiple style="display:none;" />
                    <span class="update-btn" id="updateBtn">&#128196; Update File</span>
                </label>
                <span class="update-status" id="updateStatus"></span>
            </div>

            <div class="controls-row">
                <input type="text" class="search-input" id="searchInput" placeholder="&#128269; Cari anime..." />
                <select class="sort-select" id="sortSelect">
                    <option value="a-z">A-Z</option>
                    <option value="donghua">Donghua</option>
                    <option value="dub">Dub Indo</option>
                </select>
            </div>
        </div>
    </div>

    <div class="container">
        <div class="grid" id="animeGrid">
            <div class="loading">&#9203; Memuat koleksi anime...</div>
        </div>
    </div>

    <!-- JSZip for extracting .zip files -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js" integrity="sha512-XMVd28F1oH/O71fzwBnV7HucLxVwtxf26XV8P4wPk26EDxuGZ91N8bsOttmnomcCD3CS5ZMRL50H0GgOHvegtg==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
    <script src="update_data.js" onerror="void 0"></script>
    <script>
        let animeData = [];
        const icons = ['&#127917;','&#9876;&#65039;','&#11088;','&#128293;','&#128167;','&#9889;','&#127919;','&#127800;','&#127914;','&#127912;','&#127925;','&#127982;','&#127769;','&#127774;','&#127888;'];
        const colors = ['#ff6b6b','#4ecdc4','#ffe66d','#a8e6cf','#ffd93d','#6bcf7f','#95e1d3','#f38181','#aa96da','#fcbad3'];

        function hashStr(s) {
            let h = 0;
            for (let i = 0; i < s.length; i++) h = (Math.imul(31, h) + s.charCodeAt(i)) | 0;
            return Math.abs(h);
        }

        function createAnimeCard(anime) {
            const card = document.createElement('a');
            card.className = 'anime-card';
            card.href = 'player.html?anime=' + encodeURIComponent(anime.name);
            const h = hashStr(anime.name), icon = icons[h % icons.length], color = colors[h % colors.length];
            const thumbId = anime.thumbnail_video_id;
            const hqUrl = thumbId ? 'https://img.youtube.com/vi/' + thumbId + '/hqdefault.jpg' : null;
            const mqUrl = thumbId ? 'https://img.youtube.com/vi/' + thumbId + '/mqdefault.jpg' : null;
            
            const isDub = anime.name.includes('Dub Indo');
            const badges = [];
            if (anime.is_donghua) badges.push('<div class="badge donghua">Donghua</div>');
            if (isDub) badges.push('<div class="badge dub">Dub Indo</div>');

            card.innerHTML =
                badges.join('') +
                '<div class="thumbnail">' +
                (hqUrl ? '<img class="thumb-img" src="' + hqUrl + '" alt="' + anime.name.replace(/"/g,'&quot;') + '"' +
                  ' onerror="this.src=\'' + mqUrl + '\'; this.onerror=function(){this.style.display=\'none\'; this.nextElementSibling.style.display=\'flex\';}" />' : '') +
                '<div class="thumb-fallback" style="background:linear-gradient(135deg,' + color + '33 0%,' + color + '66 100%);' + (hqUrl ? '' : 'display:flex;') + '">' +
                '<div class="anime-icon">' + icon + '</div></div></div>' +
                '<div class="info"><div class="title">' + anime.name.replace(' (Dub Indo)', '') + '</div>' +
                '<div class="meta">' + anime.episode_count + ' Episodes</div></div>';
            return card;
        }

        function levenshtein(s1, s2) {
            if (s1.length < s2.length) [s1, s2] = [s2, s1];
            if (s2.length === 0) return s1.length;
            let prev = Array.from({length: s2.length + 1}, (_, i) => i);
            for (let i = 0; i < s1.length; i++) {
                let curr = [i + 1];
                for (let j = 0; j < s2.length; j++) {
                    curr.push(Math.min(prev[j + 1] + 1, curr[j] + 1, prev[j] + (s1[i] === s2[j] ? 0 : 1)));
                }
                prev = curr;
            }
            return prev[s2.length];
        }

        function fuzzyMatch(query, text) {
            const q = query.toLowerCase().trim();
            const t = text.toLowerCase().trim();
            if (!q) return true;
            if (t.includes(q)) return true; // Direct match
            
            // Levenshtein (typo tolerance up to 3)
            if (levenshtein(q, t) <= 3) return true;

            // Subsequence match fallback
            const qClean = q.replace(/[^a-z0-9]/g, '');
            const tClean = t.replace(/[^a-z0-9]/g, '');
            let qIdx = 0;
            for (let i = 0; i < tClean.length && qIdx < qClean.length; i++) {
                if (tClean[i] === qClean[qIdx]) qIdx++;
            }
            return qIdx === qClean.length;
        }

        function applyFilterAndSort() {
            const term = document.getElementById('searchInput').value;
            const sortMode = document.getElementById('sortSelect').value;
            
            let filtered = animeData.filter(a => fuzzyMatch(term, a.name));

            filtered.sort((a, b) => {
                if (sortMode === 'donghua') {
                    if (a.is_donghua !== b.is_donghua) return a.is_donghua ? -1 : 1;
                } else if (sortMode === 'dub') {
                    const aDub = a.name.includes('Dub Indo');
                    const bDub = b.name.includes('Dub Indo');
                    if (aDub !== bDub) return aDub ? -1 : 1;
                }
                return a.name.localeCompare(b.name);
            });

            renderAnime(filtered);
        }

        function renderAnime(list) {
            const grid = document.getElementById('animeGrid');
            if (list.length === 0) {
                grid.innerHTML = '<div class="no-results"><div class="no-results-icon">&#128269;</div><h2>Tidak ditemukan</h2><p>Coba kata kunci lain</p></div>';
                return;
            }
            grid.innerHTML = '';
            list.forEach(a => grid.appendChild(createAnimeCard(a)));
        }

        function showStats(data) {
            const totalEps = data.anime_list.reduce((s, a) => s + a.episode_count, 0);
            document.getElementById('stats').textContent = data.total_series + ' Anime Series \u2022 ' + totalEps + ' Total Episodes';
        }

        async function loadAnimeData() {
            let data = null;
            if (typeof AnimeUpdater !== 'undefined') {
                data = await AnimeUpdater.loadData('anime_data.json');
            } else {
                try { const r = localStorage.getItem('anime_data'); if (r) data = JSON.parse(r); } catch(e) {}
                if (!data) { try { data = await (await fetch('anime_data.json')).json(); } catch(e) {} }
            }
            if (!data || !data.anime_list) {
                document.getElementById('animeGrid').innerHTML = '<div class="loading">&#10060; Tidak ada data.</div>';
                return;
            }
            animeData = data.anime_list;
            showStats(data);
            applyFilterAndSort();
        }

        // Extract all .txt files from a .zip file
        async function extractZip(file) {
            if (typeof JSZip === 'undefined') throw new Error('JSZip tidak tersedia');
            const zip = await JSZip.loadAsync(file);
            const txtFiles = [];
            
            for (const [filename, zipEntry] of Object.entries(zip.files)) {
                if (!zipEntry.dir && /\.txt$/i.test(filename)) {
                    const content = await zipEntry.async('text');
                    txtFiles.push(content);
                }
            }
            
            return txtFiles;
        }

        function setupUpdater() {
            if (typeof AnimeUpdater === 'undefined') return;
            document.getElementById('updateRow').style.display = 'flex';

            const btn = document.getElementById('updateBtn');
            let longPressTimer = null;

            // Right-click / long-press = clear localStorage
            btn.addEventListener('contextmenu', function(e) {
                e.preventDefault();
                if (confirm('Hapus semua data localStorage dan reload dari server?')) {
                    localStorage.removeItem('anime_data');
                    document.getElementById('updateStatus').textContent = '\u2713 localStorage dihapus';
                    setTimeout(() => location.reload(), 600);
                }
            });

            btn.addEventListener('touchstart', function(e) {
                longPressTimer = setTimeout(() => {
                    if (confirm('Hapus semua data localStorage dan reload dari server?')) {
                        localStorage.removeItem('anime_data');
                        document.getElementById('updateStatus').textContent = '\u2713 localStorage dihapus';
                        setTimeout(() => location.reload(), 600);
                    }
                }, 800);
            });
            btn.addEventListener('touchend', () => { if (longPressTimer) clearTimeout(longPressTimer); });
            btn.addEventListener('touchmove', () => { if (longPressTimer) clearTimeout(longPressTimer); });

            document.getElementById('txtFileInput').addEventListener('change', async function() {
                if (!this.files || this.files.length === 0) return;
                const status = document.getElementById('updateStatus');
                status.textContent = 'Membaca file...';

                try {
                    // Read all files â€” handle both .txt and .zip
                    const contents = [];
                    for (const file of this.files) {
                        if (file.name.toLowerCase().endsWith('.zip')) {
                            status.textContent = 'Membaca ZIP: ' + file.name + '...';
                            const zipContents = await extractZip(file);
                            contents.push(...zipContents);
                        } else {
                            contents.push(await file.text());
                        }
                    }

                    if (contents.length === 0) {
                        status.textContent = '\u274C Tidak ada file .txt ditemukan';
                        return;
                    }

                    status.textContent = 'Memproses ' + contents.length + ' file...';

                    const groups = AnimeUpdater.parseMultiple(contents);
                    const existing = AnimeUpdater.loadLocal() || (animeData.length ? { anime_list: animeData } : null);

                    // Sync vs Append mode
                    let finalGroups = groups;
                    if (existing && existing.anime_list && existing.anime_list.length > 0) {
                        const existingNames = new Set(existing.anime_list.map(a => a.name.toLowerCase()));
                        const newNames = new Set(Array.from(groups.keys()).map(n => n.toLowerCase()));
                        const wouldRemove = existing.anime_list.filter(a => !newNames.has(a.name.toLowerCase())).length;

                        if (wouldRemove > 0) {
                            const syncMode = confirm(
                                'Mode SYNC?\n\n' +
                                'YES = Hapus ' + wouldRemove + ' anime yang tidak ada di file ini\n' +
                                'NO = Tambahkan/update saja (append mode, aman)'
                            );

                            if (!syncMode) {
                                // APPEND MODE
                                existing.anime_list.forEach(anime => {
                                    if (!newNames.has(anime.name.toLowerCase())) {
                                        const videoMap = new Map(anime.videos.map(v => [v.video_id, v]));
                                        finalGroups.set(anime.name, videoMap);
                                    }
                                });
                            }
                        }
                    }

                    const { data, stats } = AnimeUpdater.mergeData(existing, finalGroups);
                    const saved = AnimeUpdater.saveLocal(data);

                    animeData = data.anime_list;
                    showStats(data);
                    applyFilterAndSort();

                    status.textContent = '\u2713 +' + stats.added + ' baru, \u2212' + stats.removed +
                        ' dihapus, ' + stats.updated + ' diperbarui' + (saved ? '' : ' (localStorage penuh)');
                    if (!saved) AnimeUpdater.saveData(data);
                } catch(e) {
                    status.textContent = '\u274C ' + e.message;
                    console.error(e);
                }
                this.value = '';
            });
        }

        document.getElementById('searchInput').addEventListener('input', applyFilterAndSort);
        document.getElementById('sortSelect').addEventListener('change', applyFilterAndSort);

        loadAnimeData();
        setupUpdater();
    </script>
</body>
</html>
